//go:build !ignore_autogenerated

/*
Copyright 2022 Upbound Inc.
Copyright 2023 Jakob Schlagenhaufer, Jan Dittrich
Copyright 2025 Yannick Schlosser, Jan Dittrich
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1) DeepCopyInto(out *ClusterV1) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1.
func (in *ClusterV1) DeepCopy() *ClusterV1 {
	if in == nil {
		return nil
	}
	out := new(ClusterV1)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterV1) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1InitParameters) DeepCopyInto(out *ClusterV1InitParameters) {
	*out = *in
	if in.ClusterTemplateID != nil {
		in, out := &in.ClusterTemplateID, &out.ClusterTemplateID
		*out = new(string)
		**out = **in
	}
	if in.CreateTimeout != nil {
		in, out := &in.CreateTimeout, &out.CreateTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DiscoveryURL != nil {
		in, out := &in.DiscoveryURL, &out.DiscoveryURL
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedNetworkRef != nil {
		in, out := &in.FixedNetworkRef, &out.FixedNetworkRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedNetworkSelector != nil {
		in, out := &in.FixedNetworkSelector, &out.FixedNetworkSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnetRef != nil {
		in, out := &in.FixedSubnetRef, &out.FixedSubnetRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedSubnetSelector != nil {
		in, out := &in.FixedSubnetSelector, &out.FixedSubnetSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Keypair != nil {
		in, out := &in.Keypair, &out.Keypair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterCount != nil {
		in, out := &in.MasterCount, &out.MasterCount
		*out = new(float64)
		**out = **in
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1InitParameters.
func (in *ClusterV1InitParameters) DeepCopy() *ClusterV1InitParameters {
	if in == nil {
		return nil
	}
	out := new(ClusterV1InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1List) DeepCopyInto(out *ClusterV1List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClusterV1, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1List.
func (in *ClusterV1List) DeepCopy() *ClusterV1List {
	if in == nil {
		return nil
	}
	out := new(ClusterV1List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClusterV1List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1Observation) DeepCopyInto(out *ClusterV1Observation) {
	*out = *in
	if in.APIAddress != nil {
		in, out := &in.APIAddress, &out.APIAddress
		*out = new(string)
		**out = **in
	}
	if in.ClusterTemplateID != nil {
		in, out := &in.ClusterTemplateID, &out.ClusterTemplateID
		*out = new(string)
		**out = **in
	}
	if in.CoeVersion != nil {
		in, out := &in.CoeVersion, &out.CoeVersion
		*out = new(string)
		**out = **in
	}
	if in.ContainerVersion != nil {
		in, out := &in.ContainerVersion, &out.ContainerVersion
		*out = new(string)
		**out = **in
	}
	if in.CreateTimeout != nil {
		in, out := &in.CreateTimeout, &out.CreateTimeout
		*out = new(float64)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DiscoveryURL != nil {
		in, out := &in.DiscoveryURL, &out.DiscoveryURL
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Keypair != nil {
		in, out := &in.Keypair, &out.Keypair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterAddresses != nil {
		in, out := &in.MasterAddresses, &out.MasterAddresses
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.MasterCount != nil {
		in, out := &in.MasterCount, &out.MasterCount
		*out = new(float64)
		**out = **in
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeAddresses != nil {
		in, out := &in.NodeAddresses, &out.NodeAddresses
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.StackID != nil {
		in, out := &in.StackID, &out.StackID
		*out = new(string)
		**out = **in
	}
	if in.UpdatedAt != nil {
		in, out := &in.UpdatedAt, &out.UpdatedAt
		*out = new(string)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1Observation.
func (in *ClusterV1Observation) DeepCopy() *ClusterV1Observation {
	if in == nil {
		return nil
	}
	out := new(ClusterV1Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1Parameters) DeepCopyInto(out *ClusterV1Parameters) {
	*out = *in
	if in.ClusterTemplateID != nil {
		in, out := &in.ClusterTemplateID, &out.ClusterTemplateID
		*out = new(string)
		**out = **in
	}
	if in.CreateTimeout != nil {
		in, out := &in.CreateTimeout, &out.CreateTimeout
		*out = new(float64)
		**out = **in
	}
	if in.DiscoveryURL != nil {
		in, out := &in.DiscoveryURL, &out.DiscoveryURL
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedNetworkRef != nil {
		in, out := &in.FixedNetworkRef, &out.FixedNetworkRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedNetworkSelector != nil {
		in, out := &in.FixedNetworkSelector, &out.FixedNetworkSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnetRef != nil {
		in, out := &in.FixedSubnetRef, &out.FixedSubnetRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.FixedSubnetSelector != nil {
		in, out := &in.FixedSubnetSelector, &out.FixedSubnetSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Keypair != nil {
		in, out := &in.Keypair, &out.Keypair
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterCount != nil {
		in, out := &in.MasterCount, &out.MasterCount
		*out = new(float64)
		**out = **in
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1Parameters.
func (in *ClusterV1Parameters) DeepCopy() *ClusterV1Parameters {
	if in == nil {
		return nil
	}
	out := new(ClusterV1Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1Spec) DeepCopyInto(out *ClusterV1Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1Spec.
func (in *ClusterV1Spec) DeepCopy() *ClusterV1Spec {
	if in == nil {
		return nil
	}
	out := new(ClusterV1Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClusterV1Status) DeepCopyInto(out *ClusterV1Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClusterV1Status.
func (in *ClusterV1Status) DeepCopy() *ClusterV1Status {
	if in == nil {
		return nil
	}
	out := new(ClusterV1Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1) DeepCopyInto(out *ClustertemplateV1) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1.
func (in *ClustertemplateV1) DeepCopy() *ClustertemplateV1 {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClustertemplateV1) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1InitParameters) DeepCopyInto(out *ClustertemplateV1InitParameters) {
	*out = *in
	if in.ApiserverPort != nil {
		in, out := &in.ApiserverPort, &out.ApiserverPort
		*out = new(float64)
		**out = **in
	}
	if in.ClusterDistro != nil {
		in, out := &in.ClusterDistro, &out.ClusterDistro
		*out = new(string)
		**out = **in
	}
	if in.Coe != nil {
		in, out := &in.Coe, &out.Coe
		*out = new(string)
		**out = **in
	}
	if in.DNSNameserver != nil {
		in, out := &in.DNSNameserver, &out.DNSNameserver
		*out = new(string)
		**out = **in
	}
	if in.DockerStorageDriver != nil {
		in, out := &in.DockerStorageDriver, &out.DockerStorageDriver
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.ExternalNetworkID != nil {
		in, out := &in.ExternalNetworkID, &out.ExternalNetworkID
		*out = new(string)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HTTPProxy != nil {
		in, out := &in.HTTPProxy, &out.HTTPProxy
		*out = new(string)
		**out = **in
	}
	if in.HTTPSProxy != nil {
		in, out := &in.HTTPSProxy, &out.HTTPSProxy
		*out = new(string)
		**out = **in
	}
	if in.Hidden != nil {
		in, out := &in.Hidden, &out.Hidden
		*out = new(bool)
		**out = **in
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(string)
		**out = **in
	}
	if in.InsecureRegistry != nil {
		in, out := &in.InsecureRegistry, &out.InsecureRegistry
		*out = new(string)
		**out = **in
	}
	if in.KeypairID != nil {
		in, out := &in.KeypairID, &out.KeypairID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkDriver != nil {
		in, out := &in.NetworkDriver, &out.NetworkDriver
		*out = new(string)
		**out = **in
	}
	if in.NoProxy != nil {
		in, out := &in.NoProxy, &out.NoProxy
		*out = new(string)
		**out = **in
	}
	if in.Public != nil {
		in, out := &in.Public, &out.Public
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RegistryEnabled != nil {
		in, out := &in.RegistryEnabled, &out.RegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ServerType != nil {
		in, out := &in.ServerType, &out.ServerType
		*out = new(string)
		**out = **in
	}
	if in.TLSDisabled != nil {
		in, out := &in.TLSDisabled, &out.TLSDisabled
		*out = new(bool)
		**out = **in
	}
	if in.VolumeDriver != nil {
		in, out := &in.VolumeDriver, &out.VolumeDriver
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1InitParameters.
func (in *ClustertemplateV1InitParameters) DeepCopy() *ClustertemplateV1InitParameters {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1List) DeepCopyInto(out *ClustertemplateV1List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClustertemplateV1, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1List.
func (in *ClustertemplateV1List) DeepCopy() *ClustertemplateV1List {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ClustertemplateV1List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1Observation) DeepCopyInto(out *ClustertemplateV1Observation) {
	*out = *in
	if in.ApiserverPort != nil {
		in, out := &in.ApiserverPort, &out.ApiserverPort
		*out = new(float64)
		**out = **in
	}
	if in.ClusterDistro != nil {
		in, out := &in.ClusterDistro, &out.ClusterDistro
		*out = new(string)
		**out = **in
	}
	if in.Coe != nil {
		in, out := &in.Coe, &out.Coe
		*out = new(string)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DNSNameserver != nil {
		in, out := &in.DNSNameserver, &out.DNSNameserver
		*out = new(string)
		**out = **in
	}
	if in.DockerStorageDriver != nil {
		in, out := &in.DockerStorageDriver, &out.DockerStorageDriver
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.ExternalNetworkID != nil {
		in, out := &in.ExternalNetworkID, &out.ExternalNetworkID
		*out = new(string)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HTTPProxy != nil {
		in, out := &in.HTTPProxy, &out.HTTPProxy
		*out = new(string)
		**out = **in
	}
	if in.HTTPSProxy != nil {
		in, out := &in.HTTPSProxy, &out.HTTPSProxy
		*out = new(string)
		**out = **in
	}
	if in.Hidden != nil {
		in, out := &in.Hidden, &out.Hidden
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(string)
		**out = **in
	}
	if in.InsecureRegistry != nil {
		in, out := &in.InsecureRegistry, &out.InsecureRegistry
		*out = new(string)
		**out = **in
	}
	if in.KeypairID != nil {
		in, out := &in.KeypairID, &out.KeypairID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkDriver != nil {
		in, out := &in.NetworkDriver, &out.NetworkDriver
		*out = new(string)
		**out = **in
	}
	if in.NoProxy != nil {
		in, out := &in.NoProxy, &out.NoProxy
		*out = new(string)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.Public != nil {
		in, out := &in.Public, &out.Public
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RegistryEnabled != nil {
		in, out := &in.RegistryEnabled, &out.RegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ServerType != nil {
		in, out := &in.ServerType, &out.ServerType
		*out = new(string)
		**out = **in
	}
	if in.TLSDisabled != nil {
		in, out := &in.TLSDisabled, &out.TLSDisabled
		*out = new(bool)
		**out = **in
	}
	if in.UpdatedAt != nil {
		in, out := &in.UpdatedAt, &out.UpdatedAt
		*out = new(string)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(string)
		**out = **in
	}
	if in.VolumeDriver != nil {
		in, out := &in.VolumeDriver, &out.VolumeDriver
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1Observation.
func (in *ClustertemplateV1Observation) DeepCopy() *ClustertemplateV1Observation {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1Parameters) DeepCopyInto(out *ClustertemplateV1Parameters) {
	*out = *in
	if in.ApiserverPort != nil {
		in, out := &in.ApiserverPort, &out.ApiserverPort
		*out = new(float64)
		**out = **in
	}
	if in.ClusterDistro != nil {
		in, out := &in.ClusterDistro, &out.ClusterDistro
		*out = new(string)
		**out = **in
	}
	if in.Coe != nil {
		in, out := &in.Coe, &out.Coe
		*out = new(string)
		**out = **in
	}
	if in.DNSNameserver != nil {
		in, out := &in.DNSNameserver, &out.DNSNameserver
		*out = new(string)
		**out = **in
	}
	if in.DockerStorageDriver != nil {
		in, out := &in.DockerStorageDriver, &out.DockerStorageDriver
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.ExternalNetworkID != nil {
		in, out := &in.ExternalNetworkID, &out.ExternalNetworkID
		*out = new(string)
		**out = **in
	}
	if in.FixedNetwork != nil {
		in, out := &in.FixedNetwork, &out.FixedNetwork
		*out = new(string)
		**out = **in
	}
	if in.FixedSubnet != nil {
		in, out := &in.FixedSubnet, &out.FixedSubnet
		*out = new(string)
		**out = **in
	}
	if in.Flavor != nil {
		in, out := &in.Flavor, &out.Flavor
		*out = new(string)
		**out = **in
	}
	if in.FloatingIPEnabled != nil {
		in, out := &in.FloatingIPEnabled, &out.FloatingIPEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HTTPProxy != nil {
		in, out := &in.HTTPProxy, &out.HTTPProxy
		*out = new(string)
		**out = **in
	}
	if in.HTTPSProxy != nil {
		in, out := &in.HTTPSProxy, &out.HTTPSProxy
		*out = new(string)
		**out = **in
	}
	if in.Hidden != nil {
		in, out := &in.Hidden, &out.Hidden
		*out = new(bool)
		**out = **in
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(string)
		**out = **in
	}
	if in.InsecureRegistry != nil {
		in, out := &in.InsecureRegistry, &out.InsecureRegistry
		*out = new(string)
		**out = **in
	}
	if in.KeypairID != nil {
		in, out := &in.KeypairID, &out.KeypairID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MasterFlavor != nil {
		in, out := &in.MasterFlavor, &out.MasterFlavor
		*out = new(string)
		**out = **in
	}
	if in.MasterLBEnabled != nil {
		in, out := &in.MasterLBEnabled, &out.MasterLBEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkDriver != nil {
		in, out := &in.NetworkDriver, &out.NetworkDriver
		*out = new(string)
		**out = **in
	}
	if in.NoProxy != nil {
		in, out := &in.NoProxy, &out.NoProxy
		*out = new(string)
		**out = **in
	}
	if in.Public != nil {
		in, out := &in.Public, &out.Public
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RegistryEnabled != nil {
		in, out := &in.RegistryEnabled, &out.RegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ServerType != nil {
		in, out := &in.ServerType, &out.ServerType
		*out = new(string)
		**out = **in
	}
	if in.TLSDisabled != nil {
		in, out := &in.TLSDisabled, &out.TLSDisabled
		*out = new(bool)
		**out = **in
	}
	if in.VolumeDriver != nil {
		in, out := &in.VolumeDriver, &out.VolumeDriver
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1Parameters.
func (in *ClustertemplateV1Parameters) DeepCopy() *ClustertemplateV1Parameters {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1Spec) DeepCopyInto(out *ClustertemplateV1Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1Spec.
func (in *ClustertemplateV1Spec) DeepCopy() *ClustertemplateV1Spec {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ClustertemplateV1Status) DeepCopyInto(out *ClustertemplateV1Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ClustertemplateV1Status.
func (in *ClustertemplateV1Status) DeepCopy() *ClustertemplateV1Status {
	if in == nil {
		return nil
	}
	out := new(ClustertemplateV1Status)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1) DeepCopyInto(out *NodegroupV1) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1.
func (in *NodegroupV1) DeepCopy() *NodegroupV1 {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodegroupV1) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1InitParameters) DeepCopyInto(out *NodegroupV1InitParameters) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.ImageID != nil {
		in, out := &in.ImageID, &out.ImageID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Role != nil {
		in, out := &in.Role, &out.Role
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1InitParameters.
func (in *NodegroupV1InitParameters) DeepCopy() *NodegroupV1InitParameters {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1InitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1List) DeepCopyInto(out *NodegroupV1List) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]NodegroupV1, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1List.
func (in *NodegroupV1List) DeepCopy() *NodegroupV1List {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1List)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NodegroupV1List) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1Observation) DeepCopyInto(out *NodegroupV1Observation) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ImageID != nil {
		in, out := &in.ImageID, &out.ImageID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Role != nil {
		in, out := &in.Role, &out.Role
		*out = new(string)
		**out = **in
	}
	if in.UpdatedAt != nil {
		in, out := &in.UpdatedAt, &out.UpdatedAt
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1Observation.
func (in *NodegroupV1Observation) DeepCopy() *NodegroupV1Observation {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1Observation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1Parameters) DeepCopyInto(out *NodegroupV1Parameters) {
	*out = *in
	if in.ClusterID != nil {
		in, out := &in.ClusterID, &out.ClusterID
		*out = new(string)
		**out = **in
	}
	if in.DockerVolumeSize != nil {
		in, out := &in.DockerVolumeSize, &out.DockerVolumeSize
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.ImageID != nil {
		in, out := &in.ImageID, &out.ImageID
		*out = new(string)
		**out = **in
	}
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.MaxNodeCount != nil {
		in, out := &in.MaxNodeCount, &out.MaxNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.MergeLabels != nil {
		in, out := &in.MergeLabels, &out.MergeLabels
		*out = new(bool)
		**out = **in
	}
	if in.MinNodeCount != nil {
		in, out := &in.MinNodeCount, &out.MinNodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Role != nil {
		in, out := &in.Role, &out.Role
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1Parameters.
func (in *NodegroupV1Parameters) DeepCopy() *NodegroupV1Parameters {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1Parameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1Spec) DeepCopyInto(out *NodegroupV1Spec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1Spec.
func (in *NodegroupV1Spec) DeepCopy() *NodegroupV1Spec {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NodegroupV1Status) DeepCopyInto(out *NodegroupV1Status) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NodegroupV1Status.
func (in *NodegroupV1Status) DeepCopy() *NodegroupV1Status {
	if in == nil {
		return nil
	}
	out := new(NodegroupV1Status)
	in.DeepCopyInto(out)
	return out
}
